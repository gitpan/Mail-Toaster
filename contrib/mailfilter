SHELL="/bin/sh"
import EXT
import HOST
VHOME=`pwd`
TIMESTAMP=`date "+%b %d %H:%M:%S"`

##
#  title:  mailfilter-site
#  author: Matt Simerson
#  version 2.2
#  http://mail-toaster.org/etc/mailfilter-site
#
#  Usage: Install this file in /usr/local/etc/mail/mailfilter (or whereever)
#
#  Create a .qmail file in each users Maildir as follows:
#  echo "/usr/local/bin/maildrop /usr/local/etc/mail/mailfilter" \
#      > ~vpopmail/domains/simerson.net/matt/.qmail
#
#  You can also use qmailadmin v1.0.26 or higher to do that for you
#  via it's --enable-modify-spam and --enable-spam-command options.
#
#  After your satisifed that it's working properly, comment out all
#  the lines that start with "log"
##

logfile "/var/log/mail/maildrop.log"

log "$TIMESTAMP - BEGIN maildrop processing for $EXT@$HOST ==="

##
# Comment out this section if you run SpamAssassin via qmailscanner
# Spamassassin is slow enough, no point in doubling your expense
#
# Note that if you want to pass a message larger than 250k to spamd
# and have it processed, you'll need to also set spamc -s. See the 
# spamc man page for more details. 
##

exception {
	if ( $SIZE < 256000 ) # Filter if message is less 250k
	{
		`test -x /usr/local/bin/spamc`
		if ( $RETURNCODE == 0 )
		{
			log "   running message through spamc"
			exception {
				xfilter '/usr/local/bin/spamc -u "$EXT@$HOST"'
			}
		}
		else
		{
			log "   WARNING: no /usr/local/bin/spamc binary!"
		}
	}
}

##
# Include any rules set up for the user - this gives the 
#   administrator a way to override the sitewide mailfilter file
#
#   this is also the "suggested" way to set individual values
#   for maildrop such as quota.
##
`test -r $VHOME/.mailfilter`
if( $RETURNCODE == 0 )
{
	log "   including $VHOME/.mailfilter"
	exception {
		include $VHOME/.mailfilter
	}
}

## 
# create the maildirsize file if it doesn't already exist
# (could also be done via "deliverquota user@dom.com 10MS,1000C)
##
`test -e $VHOME/Maildir/maildirsize`
if( $RETURNCODE == 1)
{
	`test -x /usr/local/vpopmail/bin/vuserinfo`
	if ( $RETURNCODE == 0)
	{
		log "   creating $VHOME/Maildir/maildirsize for quotas"
		`/usr/local/vpopmail/bin/vuserinfo -Q $EXT@$HOST`

		`test -s "$VHOME/Maildir/maildirsize"`
   	if ( $RETURNCODE == 0 )
   	{
     		`/usr/sbin/chown vpopmail:vchkpw $VHOME/Maildir/maildirsize`
			`/bin/chmod 640 $VHOME/Maildir/maildirsize`
   	}
	}
	else
	{
		log "   WARNING: cannot find vuserinfo! Please edit mailfilter"
	}
}

##
# Set MAILDIRQUOTA. If this isn't set, maildrop and deliverquota
# will not enforce quotas for message delivery.
#
# I find this much easier than creating yet another config file
# to store this in. This way, any time the quota is changed in
# vpopmail, it'll get noticed by maildrop immediately.
##

`test -e $VHOME/Maildir/maildirsize`
if( $RETURNCODE == 0)
{
	MAILDIRQUOTA=`/usr/bin/head -n1 $VHOME/Maildir/maildirsize`
}

##
# The message should be tagged, so let's bag it.
##
# if ( /^X-Spam-Status: *Yes/)  # test if spam status is yes
# The following regexp matches any spam message and sets the
# variable $MATCH2 to the spam score.

if ( /^X-Spam-Status: Yes, hits=![0-9]+\.[0-9]+! /:h)
{
	# if the message scored a 12 or higher, then there isn't any point
	# in keeping it around. SpamAssassin already knows it's spam, and
	# has already "autolearned" from it if you have that enabled. The
	# end user likely doesn't want it. If you wanted to cc it, or
	# deliver it elsewhere for inclusion in a spam corpus, you could
	# easily do so with a cc or xfilter command

#	if ( $MATCH2 >= 12 )   # from Adam Senuik post to mail-toasters
#	{
#		log "   SPAM: score $MATCH2: nuking message!"
#		log "=== END === $EXT@$HOST success (discarded)"
#		EXITCODE=0
#		exit
#	}

	# if the user doesnt' have a Spam folder, we create it.

	`test -d $VHOME/Maildir/.Spam`
	if( $RETURNCODE == 1 )
	{
		log "   creating $VHOME/Maildir/.Spam "
		`maildirmake -f Spam $VHOME/Maildir`
		`/usr/local/sbin/subscribeIMAP.sh Spam $VHOME`
	}

	log "   SPAM: score $MATCH2: delivering to $VHOME/Maildir/.Spam"

	# make sure the deliverquota binary exists and is executable
	# if not, then we cannot enforce quotas. If you don't check
	# for this, and the binary is missing, maildrop silently
	# discards mail. Don't ask how I know this.

	`test -x /usr/local/bin/deliverquota`
	if ( $RETURNCODE == 1 )
	{
		log "   WARNING: no deliverquota!"
		log "=== END ===  $EXT@$HOST success"
		exception {
			to "$VHOME/Maildir/.Spam"
		}
	}
	else
	{
		exception {
			xfilter "/usr/local/bin/deliverquota -w 90 $VHOME/Maildir/.Spam"
		}

		if ( $RETURNCODE == 0 )
		{
			log "=== END ===  $EXT@$HOST  success (quota)"
			EXITCODE=0
			exit
		}
		else
		{
			if( $RETURNCODE == 77)
			{
				log "=== END ===  $EXT@$HOST  bounced (quota)"
				to "|/var/qmail/bin/bouncesaying '$EXT@$HOST is over quota'"
			}
			else
			{
				log "=== END ===  $EXT@$HOST failure (unknown deliverquota error)"
				to "$VHOME/Maildir/.Spam"
			}
		}
	}
}


if ( /^X-Spam-Status: No, hits=![\-]*[0-9]+\.[0-9]+! /:h)
{
	log "   message is clean ($MATCH2)"
}

##
# Include any other rules that the user might have from
# sqwebmail or other compatible program
##

`test -r $VHOME/Maildir/.mailfilter`
if( $RETURNCODE == 0 )
{
	log "   including $VHOME/Maildir/.mailfilter"
	exception {
		include $VHOME/Maildir/.mailfilter
	}
}

log "   delivering to $VHOME/Maildir"

`test -x /usr/local/bin/deliverquota`
if ( $RETURNCODE == 1 )
{
	log "   WARNING: no deliverquota!"
	log "=== END ===  $EXT@$HOST success"
	exception {
		to "$VHOME/Maildir"
	}
}
else
{
	exception {
		xfilter "/usr/local/bin/deliverquota -w 90 $VHOME/Maildir"
	}

	##
	# check to make sure the message was delivered
	# returncode 77 means that out maildir was overquota - bounce mail
	##
	if( $RETURNCODE == 77)
	{
		#log "   BOUNCED: bouncesaying '$EXT@$HOST is over quota'"
		log "=== END ===  $EXT@$HOST  bounced"
		to "|/var/qmail/bin/bouncesaying '$EXT@$HOST is over quota'"
	}
	else
	{
		log "=== END ===  $EXT@$HOST  success (quota)"
		EXITCODE=0
		exit
	}
}

log "WARNING: This message should never be printed!"


# Another way of getting the EXT and HOST although I'm not
# sure why this would ever be beneficial
#
#USERNAME=`echo ${VHOME##*/}`
#USERHOST=`PWDTMP=${VHOME%/*}; echo ${PWDTMP##*/}`
#log "  VARS: USERNAME: $USERNAME, USERHOST: $USERHOST"

