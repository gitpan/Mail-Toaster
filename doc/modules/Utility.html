<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Mail::Toaster::Utility</title>
<link rev="made" href="mailto:root@b02.apple.com" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#diagnostics">DIAGNOSTICS</a></li>
	<li><a href="#dependencies">DEPENDENCIES</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#todo">TODO</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>Mail::Toaster::Utility - a collection of utility subroutines for sysadmin tasks</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  use Mail::Toaster::Utility;
  my $utility = Mail::Toaster::Utility-&gt;new;</pre>
<pre>
  $utility-&gt;file_write($file, @lines);</pre>
<p>This is just one of the many handy little methods I have amassed here. Rather than try to remember all of the best ways to code certain functions and then attempt to remember them, I have consolidated years of experience and countless references from Learning Perl, Programming Perl, Perl Best Practices, and many other sources into these subroutines.</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This Mail::Toaster::Utility package is my most frequently used one. Peruse through the list of methods and surely you too can find something of use. Each method has its own documentation but in general, all methods accept as input a hashref with at least one required argument and a number of optional arguments.</p>
<p>
</p>
<hr />
<h1><a name="diagnostics">DIAGNOSTICS</a></h1>
<p>All methods set and return error codes (0 = fail, 1 = success) unless otherwise stated.</p>
<p>Unless otherwise mentioned, all methods accept two additional parameters:</p>
<pre>
  debug - to print status and verbose error messages, set debug=&gt;1.
  fatal - die on errors. This is the default, set fatal=&gt;0 to override.</pre>
<p>
</p>
<hr />
<h1><a name="dependencies">DEPENDENCIES</a></h1>
<pre>
  Perl.
  Scalar::Util -  built-in as of perl 5.8</pre>
<p>Almost nothing else. A few of the methods do require certian things, like archive_expand requires tar and file. But in general, this package (Mail::Toaster::Utility) should run flawlessly on any UNIX-like system. Because I recycle this package in other places (not just Mail::Toaster), I avoid creating dependencies here.</p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="item_new">new</a></strong><br />
</dt>
<dd>
To use any of the methods below, you must first create a utility object. The methods can be accessed via the utility object.
</dd>
<dd>
<pre>
  ############################################
  # Usage      : use Mail::Toaster::Utility;
  #            : my $utility = Mail::Toaster::Utility-&gt;new;
  # Purpose    : create a new Mail::Toaster::Utility object
  # Returns    : a bona fide object
  # Parameters : none
  ############################################</pre>
</dd>
<p></p>
<dt><strong><a name="item_answer">answer</a></strong><br />
</dt>
<dd>
Get a response from the user. If the user responds, their response is returned. If not, then the default response is returned. If no default was supplied, 0 is returned.
</dd>
<dd>
<pre>
  ############################################
  # Usage      :  my $answer = $utility-&gt;answer(
  #                        question =&gt; &quot;Would you like fries with that&quot;,
  #                        default  =&gt; &quot;SuperSized!&quot;,
  #                        timeout  =&gt; 30  
  #               );
  # Purpose    : prompt the user for information
  #
  # Returns    : S - the users response (if not empty) or
  #            : S - the default answer or
  #            : S - an empty string
  #
  # Parameters
  #   Required : S - question - what to ask
  #            : S - q        - a programmer friendly alias for question
  #   Optional : S - default  - a default answer
  #            : I - timeout  - how long to wait for a response
  # Throws     : no exceptions
  # See Also   : yes_or_no</pre>
</dd>
<p></p>
<dt><strong><a name="item_archive_expand">archive_expand</a></strong><br />
</dt>
<dd>
Decompresses a variety of archive formats using your systems built in tools.
</dd>
<dd>
<pre>
  ############### archive_expand ##################
  # Usage      : $utility-&gt;archive_expand(
  #            :     archive =&gt; 'example.tar.bz2' );
  # Purpose    : test the archiver, determine its contents, and then
  #              use the best available means to expand it.
  # Returns    : 0 - failure, 1 - success
  # Parameters : S - archive - a bz2, gz, or tgz file to decompress</pre>
</dd>
<p></p>
<dt><strong><a name="item_chdir_source_dir">chdir_source_dir</a></strong><br />
</dt>
<dd>
Changes the current working directory to the supplied one. Creates it if it does not exist. Tries to create the directory using perl's builtin mkdir, then the system mkdir, and finally the system mkdir with sudo.
</dd>
<dd>
<pre>
  ############ chdir_source_dir ###################
  # Usage      : $utility-&gt;chdir_source_dir( dir=&gt;&quot;/usr/local/src&quot; );
  # Purpose    : prepare a location to build source files in
  # Returns    : 0 - failure,  1 - success
  # Parameters : S - dir - a directory to build programs in</pre>
</dd>
<p></p>
<dt><strong><a name="item_check_homedir_ownership">check_homedir_ownership</a></strong><br />
</dt>
<dd>
Checks the ownership on all home directories to see if they are owned by their respective users in /etc/password. Offers to repair the permissions on incorrectly owned directories. This is useful when someone that knows better does something like ``chown -R user /home /user'' and fouls things up.
</dd>
<dd>
<pre>
  ######### check_homedir_ownership ############
  # Usage      : $utility-&gt;check_homedir_ownership();
  # Purpose    : repair user homedir ownership
  # Returns    : 0 - failure,  1 - success
  # Parameters :
  #   Optional : I - auto - no prompts, just fix everything
  # See Also   : sysadmin</pre>
</dd>
<dd>
<p>Comments: Auto mode should be run with great caution. Run it first to see the results and then, if everything looks good, run in auto mode to do the actual repairs.</p>
</dd>
<p></p>
<dt><strong><a name="item_file_chmod">file_chmod</a></strong><br />
</dt>
<dd>
Set the permissions (ugo-rwx) of a file. Will use the native perl methods (by default) but can also use system calls and prepend sudo if additional permissions are needed.
</dd>
<dd>
<pre>
  $utility-&gt;file_chmod(
                file_or_dir =&gt; '/etc/resolv.conf',
                mode =&gt; '0755',
                sudo =&gt; $sudo
  )</pre>
</dd>
<dd>
<pre>
 arguments required:
   file_or_dir - a file or directory to alter permission on
   mode   - the permissions (numeric)</pre>
</dd>
<dd>
<pre>
 arguments optional:
   sudo  - the output of $utility-&gt;sudo
   fatal - die on errors? (default: on)
   debug</pre>
</dd>
<dd>
<pre>
 result:
   0 - failure
   1 - success</pre>
</dd>
<p></p>
<dt><strong><a name="item_chown_system">chown_system</a></strong><br />
</dt>
<dd>
The advantage this sub has over a Pure Perl implementation is that it can utilize sudo to gain elevated permissions that we might not otherwise have.
</dd>
<dd>
<pre>
  ############### chown_system #################
  # Usage      : $utility-&gt;chown_system( dir=&gt;&quot;/tmp/example&quot;, user=&gt;'matt' );
  # Purpose    : change the ownership of a file or directory
  # Returns    : 0 - failure,  1 - success
  # Parameters : S - dir    - the directory to chown
  #            : S - user   - a system username
  #   Optional : S - group  - a sytem group name
  #            : I - recurse - include all files/folders in directory?
  # Comments   : Uses the system chown binary
  # See Also   : n/a</pre>
</dd>
<p></p>
<dt><strong><a name="item_clean_tmp_dir">clean_tmp_dir</a></strong><br />
</dt>
<dd>
<pre>
  ############## clean_tmp_dir ################
  # Usage      : $utility-&gt;clean_tmp_dir( dir=&gt;$dir );
  # Purpose    : clean up old build stuff before rebuilding
  # Returns    : 0 - failure,  1 - success
  # Parameters : S - $dir - a directory or file. 
  # Throws     : no exceptions
  # Comments   : Running this will delete its contents. Be careful!</pre>
</dd>
<dt><strong><a name="item_drives_get_mounted">drives_get_mounted</a></strong><br />
</dt>
<dd>
<pre>
  ############# drives_get_mounted ############
  # Usage      : my $mounts = $utility-&gt;drives_get_mounted();
  # Purpose    : Uses mount to fetch a list of mounted drive/partitions
  # Returns    : a hashref of mounted slices and their mount points.</pre>
</dd>
<dt><strong><a name="item_file_archive">file_archive</a></strong><br />
</dt>
<dd>
<pre>
  ############### file_archive #################
  # Purpose    : Make a backup copy of a file by copying the file to $file.timestamp.
  # Usage      : my $archived_file = $utility-&gt;file_archive( file=&gt;$file );
  # Returns    : the filename of the backup file, or 0 on failure.
  # Parameters : S - file - the filname to be backed up
  # Comments   : none</pre>
</dd>
<dt><strong><a name="item_file_chown">file_chown</a></strong><br />
</dt>
<dd>
Set the ownership (user and group) of a file. Will use the native perl methods (by default) but can also use system calls and prepend sudo if additional permissions are needed.
</dd>
<dd>
<pre>
  $utility-&gt;file_chown(
                file_or_dir =&gt; '/etc/resolv.conf',
                uid =&gt; 'root',
                gid =&gt; 'wheel',
                sudo =&gt; 1
  );</pre>
</dd>
<dd>
<pre>
 arguments required:
   file_or_dir - a file or directory to alter permission on
   uid   - the uid or user name
   gid   - the gid or group name</pre>
</dd>
<dd>
<pre>
 arguments optional:
   file  - alias for file_or_dir
   dir   - alias for file_or_dir
   sudo  - the output of $utility-&gt;sudo
   fatal - die on errors? (default: on)
   debug</pre>
</dd>
<dd>
<pre>
 result:
   0 - failure
   1 - success</pre>
</dd>
<p></p>
<dt><strong><a name="item_file_delete">file_delete</a></strong><br />
</dt>
<dd>
<pre>
  ############################################
  # Usage      : $utility-&gt;file_delete( file=&gt;$file );
  # Purpose    : Deletes a file.
  # Returns    : 0 - failure, 1 - success
  # Parameters 
  #   Required : file - a file path
  # Comments   : none
  # See Also   :</pre>
</dd>
<dd>
<pre>
 Uses unlink if we have appropriate permissions, otherwise uses a system rm call, using sudo if it is not being run as root. This sub will try very hard to delete the file!</pre>
</dd>
<dt><strong><a name="item_file_get">file_get</a></strong><br />
</dt>
<dd>
<pre>
   $utility-&gt;file_get( url=&gt;$url, debug=&gt;1 );</pre>
</dd>
<dd>
<p>Use the standard URL fetching utility (fetch, curl, wget) for your OS to download a file from the $url handed to us.</p>
</dd>
<dd>
<pre>
 arguments required:
   url - the fully qualified URL</pre>
</dd>
<dd>
<pre>
 arguments optional:
   timeout - the maximum amount of time to try
   fatal
   debug</pre>
</dd>
<dd>
<pre>
 result:
   1 - success
   0 - failure</pre>
</dd>
<dt><strong><a name="item_file_read">file_read</a></strong><br />
</dt>
<dd>
Reads in a file, and returns it in an array. All lines in the array are chomped.
</dd>
<dd>
<pre>
   my @lines = $utility-&gt;file_read( file=&gt;$file, max_lines=&gt;100 )</pre>
</dd>
<dd>
<pre>
 arguments required:
   file - the file to read in</pre>
</dd>
<dd>
<pre>
 arguments optional:
   max_lines  - integer - max number of lines
   max_length - integer - maximum length of a line
   fatal
   debug</pre>
</dd>
<dd>
<pre>
 result:
   0 - failure
   success - returns an array with the files contents, one line per array element</pre>
</dd>
<p></p>
<dt><strong><a name="item_file_write">file_write</a></strong><br />
</dt>
<dd>
<pre>
 usage:
   my @lines = &quot;1&quot;, &quot;2&quot;, &quot;3&quot;;  # named array
   $utility-&gt;file_write ( file=&gt;&quot;/tmp/foo&quot;, lines=&gt;\@lines );   
        or
   $utility-&gt;file_write ( file=&gt;&quot;/tmp/foo&quot;, lines=&gt;['1','2','3'] );  # anon arrayref</pre>
</dd>
<dd>
<pre>
 required arguments:
   file - the file path you want to write to
   lines - an arrayref. Each array element will be a line in the file</pre>
</dd>
<dd>
<pre>
 arguments optional:
   fatal
   debug</pre>
</dd>
<dd>
<pre>
 result:
   0 - failure
   1 - success</pre>
</dd>
<dt><strong><a name="item_files_diff">files_diff</a></strong><br />
</dt>
<dd>
Determine if the files are different. $type is assumed to be text unless you set it otherwise. For anthing but text files, we do a MD5 checksum on the files to determine if they are different or not.
</dd>
<dd>
<pre>
   $utility-&gt;files_diff( f1=&gt;$file1,f2=&gt;$file2,type=&gt;'text',debug=&gt;1 );</pre>
</dd>
<dd>
<pre>
   if ( $utility-&gt;files_diff( f1=&gt;&quot;foo&quot;, f2=&gt;&quot;bar&quot; ) )
   {
       print &quot;different!\n&quot;;
   };</pre>
</dd>
<dd>
<pre>
 required arguments:
   f1 - the first file to compare
   f2 - the second file to compare</pre>
</dd>
<dd>
<pre>
 arguments optional:
   type - the type of file (text or binary)
   fatal
   debug</pre>
</dd>
<dd>
<pre>
 result:
   0 - files are the same
   1 - files are different
  -1 - error.</pre>
</dd>
<p></p>
<dt><strong><a name="item_find_config">find_config</a></strong><br />
</dt>
<dd>
This sub is called by several others to determine which configuration file to use. The general logic is as follows:
</dd>
<dd>
<pre>
  If the etc dir and file name are provided and the file exists, use it.</pre>
</dd>
<dd>
<p>If that fails, then go prowling around the drive and look in all the usual places, in order of preference:</p>
</dd>
<dd>
<pre>
  /opt/local/etc/
  /usr/local/etc/
  /etc</pre>
</dd>
<dd>
<p>Finally, if none of those work, then check the working directory for the named .conf file, or a .conf-dist.</p>
</dd>
<dd>
<p>Example:
  my $twconf = $utility-&gt;find_config (
	  file   =&gt; 'toaster-watcher.conf', 
	  etcdir =&gt; '/usr/local/etc',
	)</p>
</dd>
<dd>
<pre>
 arguments required:
   file - the .conf file to read in</pre>
</dd>
<dd>
<pre>
 arguments optional:
   etcdir - the etc directory to prefer
   debug
   fatal</pre>
</dd>
<dd>
<pre>
 result:
   0 - failure
   the path to $file</pre>
</dd>
<p></p>
<dt><strong><a name="item_find_the_bin">find_the_bin</a></strong><br />
</dt>
<dd>
Check all the ``normal'' locations for a binary that should be on the system and returns the full path to the binary.
</dd>
<dd>
<pre>
   $utility-&gt;find_the_bin( program=&gt;'dos2unix', dir=&gt;'/opt/local/bin' );</pre>
</dd>
<dd>
<p>Example:</p>
</dd>
<dd>
<pre>
   my $apachectl = $utility-&gt;find_the_bin( program=&gt;&quot;apachectl&quot;, dir=&gt;&quot;/usr/local/sbin&quot; );</pre>
</dd>
<dd>
<pre>
 arguments required:
   program - the name of the program (its filename)</pre>
</dd>
<dd>
<pre>
 arguments optional:
   dir - a directory to check first
   fatal
   debug</pre>
</dd>
<dd>
<pre>
 results:
   0 - failure
   success will return the full path to the binary.</pre>
</dd>
<p></p>
<dt><strong><a name="item_is_process_running">is_process_running</a></strong><br />
</dt>
<dd>
Verify if a process is running or not.
</dd>
<dd>
<pre>
   $utility-&gt;is_process_running($process) ? print &quot;yes&quot; : print &quot;no&quot;;</pre>
</dd>
<dd>
<p>$process is the name as it would appear in the process table.</p>
</dd>
<p></p>
<dt><strong><a name="item_is_readable">is_readable</a></strong><br />
</dt>
<dd>
<pre>
  ############################################
  # Usage      : $utility-&gt;is_readable( file=&gt;$file );
  # Purpose    : ????
  # Returns    : 0 = no (not reabable), 1 = yes
  # Parameters : S - file - a path name to a file
  # Throws     : no exceptions
  # Comments   : none
  # See Also   : n/a</pre>
</dd>
<dd>
<pre>
  result:
     0 - no (file is not readable)
     1 - yes (file is readable)</pre>
</dd>
<dt><strong><a name="item_is_writable">is_writable</a></strong><br />
</dt>
<dd>
If the file exists, it checks to see if it is writable. If the file does not exist, it checks to see if the enclosing directory is writable.
</dd>
<dd>
<pre>
  ############################################
  # Usage      : $utility-&gt;is_writable(file =&gt;&quot;/tmp/boogers&quot;);
  # Purpose    : make sure a file is writable
  # Returns    : 0 - no (not writable), 1 - yes (is writeable)
  # Parameters : S - file - a path name to a file
  # Throws     : no exceptions</pre>
</dd>
<p></p>
<dt><strong><a name="item_fstab_list">fstab_list</a></strong><br />
</dt>
<dd>
<pre>
  ############ fstab_list ###################
  # Usage      : $utility-&gt;fstab_list;
  # Purpose    : Fetch a list of drives that are mountable from /etc/fstab.
  # Returns    : an arrayref
  # Comments   : used in backup.pl
  # See Also   : n/a</pre>
</dd>
<dt><strong><a name="item_get_dir_files">get_dir_files</a></strong><br />
</dt>
<dd>
<pre>
   $utility-&gt;get_dir_files( dir=&gt;$dir, debug=&gt;1 )</pre>
</dd>
<dd>
<pre>
 required arguments:
   dir - a directory</pre>
</dd>
<dd>
<pre>
 optional arguments:
   fatal
   debug</pre>
</dd>
<dd>
<pre>
 result:
   an array of files names contained in that directory.
   0 - failure</pre>
</dd>
<dt><strong><a name="item_get_the_date">get_the_date</a></strong><br />
</dt>
<dd>
Returns the date split into a easy to work with set of strings.
</dd>
<dd>
<pre>
   $utility-&gt;get_the_date( bump=&gt;$bump, debug=&gt;$debug )</pre>
</dd>
<dd>
<pre>
 required arguments:
   none</pre>
</dd>
<dd>
<pre>
 optional arguments:
   bump - the offset (in days) to subtract from the date.
   debug</pre>
</dd>
<dd>
<pre>
 result: (array with the following elements)
        $dd = day
        $mm = month
        $yy = year
        $lm = last month
        $hh = hours
        $mn = minutes
        $ss = seconds</pre>
</dd>
<dd>
<pre>
        my ($dd, $mm, $yy, $lm, $hh, $mn, $ss) = $utility-&gt;get_the_date();</pre>
</dd>
<p></p>
<dt><strong><a name="item_install_if_changed">install_if_changed</a></strong><br />
</dt>
<dd>
Compares two text files. If the newer file is different than the existing one, it installs it.
</dd>
<dd>
<pre>
  $utility-&gt;install_if_changed(
                newfile  =&gt; '/etc/resolv.conf.new';
                existing =&gt; '/etc/resolv.conf';
                mode     =&gt; '0755',
                uid      =&gt; 89,
        gid      =&gt; 89,
        );</pre>
</dd>
<dd>
<pre>
 arguments required
   newfile
   existing</pre>
</dd>
<dd>
<pre>
 arguments optional
   uid   -
   gid   -
   mode  - file permissions mode (numeric: 0755)
   debug - 
   clean - int - delete the newfile after installing it?
   notify- int - send notification upon updates?
   email - email address to send notifications (default: root)</pre>
</dd>
<dd>
<pre>
 results:
   0 = error (failure)
   1 = success
   2 = success, no update required</pre>
</dd>
<p></p>
<dt><strong><a name="item_install_from_source">install_from_source</a></strong><br />
</dt>
<dd>
<pre>
  usage:</pre>
</dd>
<dd>
<pre>
        $utility-&gt;install_from_source(
                package =&gt; 'simscan-1.07',
            site    =&gt; '<a href="http://www.inter7.com">http://www.inter7.com</a>',
                url     =&gt; '/simscan/',
                targets =&gt; ['./configure', 'make', 'make install'],
                patches =&gt; '',
                debug   =&gt; 1,
        );</pre>
</dd>
<dd>
<p>Downloads and installs a program from sources.</p>
</dd>
<dd>
<pre>
 required arguments:
    conf    - hashref - mail-toaster.conf settings.
    site    - 
    url     - 
    package -</pre>
</dd>
<dd>
<pre>
 optional arguments:
    targets - arrayref - defaults to [./configure, make, make install].
    patches - arrayref - patch(es) to apply to the sources before compiling
    patch_args - 
    source_sub_dir - a subdirectory within the sources build directory
    bintest - check the usual places for an executable binary. If found, it will assume the software is already installed and require confirmation before re-installing.
    debug
    fatal</pre>
</dd>
<dd>
<pre>
 result:
   1 - success
   0 - failure</pre>
</dd>
<dt><strong><a name="item_is_arrayref">is_arrayref</a></strong><br />
</dt>
<dd>
Checks whatever object is passed to it to see if it is an arrayref.
</dd>
<dd>
<pre>
   $utility-&gt;is_arrayref($testme, $debug);</pre>
</dd>
<dd>
<p>Enable debugging to see helpful error messages.</p>
</dd>
<p></p>
<dt><strong><a name="item_is_hashref">is_hashref</a></strong><br />
</dt>
<dd>
Most methods pass parameters around inside hashrefs. Unfortunately, if you try accessing a hashref method and the object isn't a hashref, it generates a fatal exception. This traps that exception and prints a useful error message.
</dd>
<dd>
<pre>
   $utility-&gt;is_hashref($hashref, $debug);</pre>
</dd>
<p></p>
<dt><strong><a name="item_logfile_append">logfile_append</a></strong><br />
</dt>
<dd>
<pre>
   $utility-&gt;logfile_append( file=&gt;$file, lines=&gt;\@lines )</pre>
</dd>
<dd>
<p>Pass a filename and an array ref and it will append a timestamp and the array contents to the file. Here's a working example:</p>
</dd>
<dd>
<pre>
   $utility-&gt;logfile_append( file=&gt;$file, prog=&gt;&quot;proggy&quot;, lines=&gt;[&quot;Starting up&quot;, &quot;Shutting down&quot;] )</pre>
</dd>
<dd>
<p>That will append a line like this to the log file:</p>
</dd>
<dd>
<pre>
   2004-11-12 23:20:06 proggy Starting up
   2004-11-12 23:20:06 proggy Shutting down</pre>
</dd>
<dd>
<pre>
 arguments required:
   file  - the log file to append to
   prog  - the name of the application
   lines - arrayref - elements are events to log.</pre>
</dd>
<dd>
<pre>
 arguments optional:
   fatal
   debug</pre>
</dd>
<dd>
<pre>
 result:
   1 - success
   0 - failure</pre>
</dd>
<dt><strong><a name="item_mailtoaster">mailtoaster</a></strong><br />
</dt>
<dd>
<pre>
   $utility-&gt;mailtoaster();</pre>
</dd>
<dd>
<p>Downloads and installs Mail::Toaster.</p>
</dd>
<dt><strong><a name="item_path_parse">path_parse</a></strong><br />
</dt>
<dd>
<pre>
   my ($up1dir, $userdir) = $utility-&gt;path_parse($dir)</pre>
</dd>
<dd>
<p>Takes a path like ``/usr/home/matt'' and returns ``/usr/home'' and ``matt''</p>
</dd>
<dd>
<p>You (and I) should be using File::Basename instead as it is more portable.</p>
</dd>
<dt><strong><a name="item_parse_config">parse_config</a></strong><br />
</dt>
<dd>
<pre>
 Example:
   my $tconf = $utility-&gt;parse_config( file=&gt;'toaster.conf' );</pre>
</dd>
<dd>
<pre>
 required parameters:
   file   - a configuration file to load settings from
   etcdir - where to look for $file - defaults to /usr/local/etc
            also checks the current working directory.</pre>
</dd>
<dd>
<pre>
 optional parameters:
   debug
   fatal</pre>
</dd>
<dd>
<pre>
 result: 
   a hashref with the key/value pairs.
   0 - failure</pre>
</dd>
<dt><strong><a name="item_pidfile_check">pidfile_check</a></strong><br />
</dt>
<dd>
pidfile_check is a process management method. It will check to make sure an existing pidfile does not exist and if not, it will create the pidfile.
</dd>
<dd>
<pre>
   $pidfile = $utility-&gt;pidfile_check( pidfile=&gt;&quot;/var/run/program.pid&quot; );</pre>
</dd>
<dd>
<p>The above example is all you need to do to add process checking (avoiding multiple daemons running at the same time) to a program or script. This is used in toaster-watcher.pl and rrdutil. toaster-watcher normally completes a run in a few seconds and is run every 5 minutes.</p>
</dd>
<dd>
<p>However, toaster-watcher can be configured to do things like expire old messages from maildirs and feed spam through a processor like sa-learn. This can take a long time on a large mail system so we don't want multiple instances of toaster-watcher running.</p>
</dd>
<dd>
<pre>
 result:
   the path to the pidfile (on success).</pre>
</dd>
<dd>
<p>Example:</p>
</dd>
<dd>
<pre>
        my $pidfile = $utility-&gt;pidfile_check( pidfile=&gt;&quot;/var/run/changeme.pid&quot; );
        unless ($pidfile) {
                warn &quot;WARNING: couldn't create a process id file!: $!\n&quot;;
                exit 0;
        };</pre>
</dd>
<dd>
<pre>
        do_a_bunch_of_cool_stuff;
        unlink $pidfile;</pre>
</dd>
<p></p>
<dt><strong><a name="item_regexp_test">regexp_test</a></strong><br />
</dt>
<dd>
Prints out a string with the regexp match bracketed. Credit to Damien Conway from Perl Best Practices.
</dd>
<dd>
<pre>
 Example:
    $utility-&gt;regexp_test( 
                exp    =&gt; 'toast', 
                string =&gt; 'mailtoaster rocks',
        );</pre>
</dd>
<dd>
<pre>
 arguments required:
   exp    - the regular expression
   string - the string you are applying the regexp to</pre>
</dd>
<dd>
<pre>
 result:
   printed string highlighting the regexp match</pre>
</dd>
<p></p>
<dt><strong><a name="item_source_warning">source_warning</a></strong><br />
</dt>
<dd>
Checks to see if the old build sources are present. If they are, offer to remove them.
</dd>
<dd>
<pre>
 Usage:</pre>
</dd>
<dd>
<pre>
   $utility-&gt;source_warning( 
                package =&gt; &quot;Mail-Toaster-4.10&quot;, 
                clean   =&gt; 1, 
                src     =&gt; &quot;/usr/local/src&quot; 
   );</pre>
</dd>
<dd>
<pre>
 arguments required:
   package - the name of the packages directory</pre>
</dd>
<dd>
<pre>
 arguments optional:
   src     - the source directory to build in (/usr/local/src)
   clean   - do we try removing the existing sources? (enabled)
   timeout - how long to wait for an answer (60 seconds)</pre>
</dd>
<dd>
<pre>
 result:
   1 - removed
   0 - failure, package exists and needs to be removed.</pre>
</dd>
<p></p>
<dt><strong><a name="item_sources_get">sources_get</a></strong><br />
</dt>
<dd>
Tries to download a set of sources files from the site and url provided. It will try first fetching a gzipped tarball and if that files, a bzipped tarball. As new formats are introduced, I will expand the support for them here.
</dd>
<dd>
<pre>
  usage:
        $self-&gt;sources_get( 
                conf    =&gt; $conf, 
                package =&gt; 'simscan-1.07', 
                site    =&gt; '<a href="http://www.inter7.com">http://www.inter7.com</a>',
                url     =&gt; '/simscan/',
        )</pre>
</dd>
<dd>
<pre>
 arguments required:
   package - the software package name
   site    - the host to fetch it from
   url     - the path to the package on $site</pre>
</dd>
<dd>
<pre>
 arguments optional:
   conf    - hashref - values from toaster-watcher.conf
   debug</pre>
</dd>
<dd>
<p>This sub proved quite useful during 2005 as many packages began to be distributed in bzip format instead of the traditional gzip.</p>
</dd>
<p></p>
<dt><strong><a name="item_sudo">sudo</a></strong><br />
</dt>
<dd>
<pre>
   my $sudo = $utility-&gt;sudo();</pre>
</dd>
<dd>
<pre>
   $utility-&gt;syscmd( command=&gt;&quot;$sudo rm /etc/root-owned-file&quot; );</pre>
</dd>
<dd>
<p>Often you want to run a script as an unprivileged user. However, the script may need elevated privileges for a plethora of reasons. Rather than running the script suid, or as root, configure sudo allowing the script to run system commands with appropriate permissions.</p>
</dd>
<dd>
<p>If sudo is not installed and you're running as root, it'll offer to install sudo for you. This is recommended, as is properly configuring sudo.</p>
</dd>
<dd>
<pre>
 arguments required:</pre>
</dd>
<dd>
<pre>
 arguments optional:
   debug</pre>
</dd>
<dd>
<pre>
 result:
   0 - failure
   on success, the full path to the sudo binary</pre>
</dd>
<dt><strong><a name="item_syscmd">syscmd</a></strong><br />
</dt>
<dd>
<pre>
   Just a little wrapper around system calls, that returns any failure codes and prints out the error(s) if present. A bit of sanity testing is also done to make sure the command to execute is safe.</pre>
</dd>
<dd>
<pre>
      my $r = $utility-&gt;syscmd( command=&gt;&quot;gzip /tmp/example.txt&quot; );
      $r ? print &quot;ok!\n&quot; : print &quot;not ok.\n&quot;;</pre>
</dd>
<dd>
<pre>
    arguments required:
      command - the command to execute
      cmd     - alias of command</pre>
</dd>
<dd>
<pre>
    arguments optional:
      debug
      fatal</pre>
</dd>
<dd>
<pre>
    result
      the exit status of the program you called.</pre>
</dd>
<dt><strong><a name="item_yes_or_no">yes_or_no</a></strong><br />
</dt>
<dd>
<pre>
  my $r = $utility-&gt;yes_or_no( 
      question =&gt; &quot;Would you like fries with that?&quot;,
      timeout  =&gt; 30
  );</pre>
</dd>
<dd>
<pre>
        $r ? print &quot;fries are in the bag\n&quot; : print &quot;no fries!\n&quot;;</pre>
</dd>
<dd>
<pre>
 arguments required:
   none.</pre>
</dd>
<dd>
<pre>
 arguments optional:
   question - the question to ask
   timeout  - how long to wait for an answer (in seconds)</pre>
</dd>
<dd>
<pre>
 result:
   0 - negative (or null)
   1 - success (affirmative)</pre>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Matt Simerson (<a href="mailto:matt@tnpi.net">matt@tnpi.net</a>)</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>None known. Report any to author.</p>
<p>
</p>
<hr />
<h1><a name="todo">TODO</a></h1>
<pre>
  make all errors raise exceptions
  write test cases for every method
  comments. always needs more comments.</pre>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>The following are all man/perldoc pages:</p>
<pre>
 Mail::Toaster 
 Mail::Toaster::Conf
 toaster.conf
 toaster-watcher.conf</pre>
<pre>
 <a href="http://mail-toaster.org/">http://mail-toaster.org/</a></pre>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright (c) 2003-2006, The Network People, Inc. All Rights Reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the The Network People, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

</body>

</html>
